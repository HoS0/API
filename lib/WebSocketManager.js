// Generated by CoffeeScript 1.10.0
(function() {
  var Amqp, RabbitMQDataManager, users, uuid, ws;

  ws = require('nodejs-websocket');

  uuid = require('uuid');

  users = [];

  RabbitMQDataManager = null;

  Amqp = null;

  exports.init = function(amqp) {
    var chat, clients, credential, generic, server, token;
    Amqp = amqp;
    clients = [];
    server = ws.createServer(function(conn) {
      var error, id;
      try {
        clients.push(conn);
        console.log("New connection");
        id = uuid.v4();
        conn.on("text", function(str) {
          var e, error, error1, obj, res;
          try {
            obj = JSON.parse(str);
            switch (obj.type) {
              case 'credential':
                return credential(conn, obj);
              case 'token':
                return token(conn, obj);
              case 'chat':
                return chat(conn, obj);
              default:
                return generic(conn, obj);
            }
          } catch (error) {
            e = error;
            res = {
              type: 'other'
            };
            res.login = false;
            res.message = "error on communication";
            try {
              return conn.sendText(JSON.stringify(res));
            } catch (error1) {
              e = error1;
            }
          }
        });
        return conn.on("close", function(code, reason) {
          var i, j, ref;
          for (i = j = 0, ref = clients.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
            if (clients[i] === conn) {
              clients.splice(i);
              break;
            }
          }
          return console.log("Connection closed");
        });
      } catch (error) {
        return console.log("error on make a connection");
      }
    }).listen(8001);
    generic = function(conn, obj) {
      if (obj.to) {
        if (obj.action !== "kill") {
          obj.responceNeeded = true;
        }
        return Amqp.SendMessage(obj.to, obj, function(amqpRes) {
          var e, error, error1, i, j, ref, results;
          if (amqpRes.broadcast) {
            results = [];
            for (i = j = 0, ref = clients.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
              try {
                results.push(clients[i].sendText(JSON.stringify(amqpRes)));
              } catch (error) {
                e = error;
              }
            }
            return results;
          } else {
            try {
              return conn.sendText(JSON.stringify(amqpRes));
            } catch (error1) {
              e = error1;
            }
          }
        });
      }
    };
    credential = function(conn, obj) {
      var e, error, res, token;
      res = {
        type: 'credential'
      };
      console.log(obj);
      if ((obj.user === "ali" || obj.user === "michele") && (obj.pass === "alikh")) {
        token = uuid.v4();
        users.push({
          token: token,
          user: obj.user
        });
        res.token = token;
        res.login = true;
      } else {
        res.login = false;
        res.message = "wrong user or pass";
      }
      try {
        return conn.sendText(JSON.stringify(res));
      } catch (error) {
        e = error;
      }
    };
    token = function(conn, obj) {
      var e, error, j, len, res, user;
      res = {
        type: 'token',
        token: obj.token
      };
      console.log(obj);
      for (j = 0, len = users.length; j < len; j++) {
        user = users[j];
        if (user.token === obj.token) {
          res.accepted = true;
        }
      }
      try {
        return conn.sendText(JSON.stringify(res));
      } catch (error) {
        e = error;
      }
    };
    return chat = function(conn, obj) {
      var j, len, user;
      for (j = 0, len = users.length; j < len; j++) {
        user = users[j];
        if (user.token === obj.payload.token) {
          obj.payload.person = user.user;
        }
      }
      return generic(conn, obj);
    };
  };

  exports.validateToken = function(token) {
    var j, len, user;
    for (j = 0, len = users.length; j < len; j++) {
      user = users[j];
      if (user.token === token) {
        return true;
      }
    }
    return false;
  };

}).call(this);
